
============================================================
OVERVIEW
============================================================
# AGENT-QA: Comprehensive Implementation Analysis

**Repository**: https://github.com/wajeehahmedkhan01/AGENT-QA.git  
**Analysis Date**: 2026-01-16  
**Status**: Demo Implementation Complete - Ready for Testing

---

## 1. Project Overview

### 1.1 Problem Statement

The AGENT-QA repository implements a **demo version of an Autonomous QA Automation WebApp** that addresses the challenge of automatically generating and executing end-to-end tests for web applications without manual test authoring. The system aims to:

- **Ingest** a website URL and observe its structure
- **Derive** a semantic model of UI elements and user flows
- **Generate** executable Playwright test scripts automatically
- **Execute** tests in isolated, read-only environments
- **Present** results and artifacts through a simple UI

### 1.2 Current Implementation Scope

The repository contains a **fully functional demo** that validates core architectural patterns and end-to-end flows. It is intentionally designed as a proof-of-concept with:

- **Deterministic behavior**: Uses mock LLM for repeatable test generation
- **Read-only safety**: All test execution is read-only by default
- **Pluggable architecture**: Clear adapter boundaries for production migration
- **Containerized deployment**: Full Docker Compose setup for local development

### 1.3 Assumptions and Limitations

**Assumptions:**

- Target websites are publicly accessible or reachable from the extractor container
- Tests focus on happy-path flows only (no error scenario generation)
- Single test per job (extensible to multiple tests)
- Local filesystem storage is sufficient for demo (S3 adapter available but not wired)

**Limitations (Demo Scope):**

- No real LLM integration by default (mock adapter used)
- No authentication/authorization (single-tenant demo)
- No multi-region or horizontal scaling
- Simple heuristic-based semantic parsing (not ML-powered)
- No test retry or failure recovery 

============================================================
ARCHITECTURE
============================================================
mechanisms
- Limited to Playwright JSON format (no other test frameworks)

---

## 2. Current Architecture

### 2.1 High-Level System Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                         Client Layer                              │
│  ┌──────────────┐                    ┌──────────────┐           │
│  │   Web UI     │                    │   API Client │           │
│  │  (React+TS)  │                    │   (curl/etc) │           │
│  │  Port 3100   │                    │              │           │
│  └──────┬───────┘                    └──────┬───────┘           │
└─────────┼────────────────────────────────────┼──────────────────┘
          │                                    │
          └────────────────┬───────────────────┘
                           │ HTTP/REST
┌──────────────────────────▼──────────────────────────────────────┐
│                      Backend API Layer                           │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │         FastAPI Application (Port 8000)                   │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │   │
│  │  │ /jobs        │  │ /tests       │  │ /health      │  │   │
│  │  │ - POST /     │  │ - POST /{id} │  │              │  │   │
│  │  │ - GET /{id}  │  │   /run       │  │              │  │   │
│  │  │ - GET /{id}  │  │              │  │              │  │   │
│  │  │   /artifacts │  │              │  │              │  │   │
│  │  │ - GET /{id}  │  │              │  │              │  │   │
│  │  │   /semantic  │  │              │  │              │  │   │
│  │  │ - POST /{id} │  │              │  │              │  │   │
│  │  │   /generate  │  │              │  │              │  │   │
│  │  │ - GET /{id}  │  │              │  │              │  │   │
│  │  │   /report    │  │              │  │              │  │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘  │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                   │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              Core Services                                │   │
│  │  • Job Management (db.py)                                │   │
│  │  • Preflight Checks (preflight.py)                       │   │
│  │  • Semantic Parser (semantic.py)                         │   │
│  │  • LLM Adapter (llm_adapter.py)                          │   │
│  │  • Test Validator (validator.py)                         │   │
│  │  • Storage Adapter (storage.py)                          │   │
│  │  • Queue Adapter (queue_adapter.py)                      │   │
│  └──────────────────────────────────────────────────────────┘   │
└──────────────────────────┬───────────────────────────────────────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                   │
┌───────▼────────┐  ┌──────▼────────┐  ┌──────▼────────┐
│   PostgreSQL   │  │     Redis    │  │  LocalFS/S3   │
│   (Port 5432)  │  │  (Port 6379)  │  │   Storage     │
│                │  │               │  │               │
│  • jobs        │  │  • jobs queue │  │  • artifacts  │
│  • consent_logs│  │  • runs queue │  │  • manifests  │
└────────────────┘  └───────────────┘  └───────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      Worker Layer                                 │
│  ┌──────────────────────┐        ┌──────────────────────┐        │
│  │  Extractor Worker    │        │   Runner Worker      │        │
│  │  (Playwright)        │        │   (Playwright)      │        │
│  │                      │        │                      │        │
│  │  • process_job()     │        │  • run_test()        │        │
│  │  • Capture DOM/HAR  │        │  • Execute steps     │        │


============================================================
BACKEND
============================================================
│  │  • Screenshot        │        │  • Capture results   │        │
│  │  • Accessibility     │        │  • Generate report   │        │
│  └──────────────────────┘        └──────────────────────┘        │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      Target Application                          │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │         Sample App (Express.js)                          │   │
│  │         Port 3000                                         │   │
│  │         /sample-app/login                                 │   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 Component Boundaries

The system is organized into **7 major components** with clear separation of concerns:

1. **Backend API** (`apps/backend/`): FastAPI application handling HTTP requests, business logic, and coordination
2. **Extractor Worker** (`apps/extractor/`): Asynchronous worker that captures page artifacts using Playwright
3. **Runner Worker** (`runner/`): Asynchronous worker that executes generated tests
4. **Web UI** (`apps/web-ui/`): React frontend for job submission and result viewing
5. **Infrastructure** (`infra/`): Docker Compose configuration and deployment scripts
6. **Sample App** (`sample-app/`): Deterministic demo target application
7. **Documentation** (`docs/`): Architecture, configuration, and runbook documentation

### 2.3 Data Flow Diagram

```
┌─────────┐
│  User   │
└────┬────┘
     │ 1. POST /jobs {targetUrl, scope, testProfile, ownerId}
     ▼
┌─────────────────────────────────────────────────────────────┐
│  Backend API                                                 │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 1. Create Job record (db.py)                          │  │
│  │ 2. Log consent (ConsentLog)                           │  │
│  │ 3. Check robots.txt (preflight.py)                    │  │
│  │ 4. Enqueue extraction (queue_adapter.py)               │  │
│  └──────────────────────────────────────────────────────┘  │
└────┬─────────────────────────────────────────────────────────┘
     │ 2. RQ Job: extractor.worker.process_job(job_id)
     ▼
┌─────────────────────────────────────────────────────────────┐
│  Extractor Worker                                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 1. Load job from DB                                   │  │
│  │ 2. Launch Playwright (Chromium)                       │  │
│  │ 3. Navigate to targetUrl                              │  │
│  │ 4. Capture:                                           │  │
│  │    • DOM snapshot (dom.json)                          │  │
│  │    • HAR trace (trace.har)                            │  │
│  │    • Screenshot (screenshot.png)                      │  │
│  │    • Accessibility tree (accessibility.json)         │  │
│  │ 5. Save artifacts via storage_adapter                 │  │
│  │ 6. Update job status                                  │  │
│  └──────────────────────────────────────────────────────┘  │
└────┬─────────────────────────────────────────────────────────┘
     │ 3. GET /jobs/{id}/semantic (on-demand)
     ▼
┌─────────────────────────────────────────────────────────────┐
│  Semantic Parser (semantic.py)                               │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 1. Parse DOM with BeautifulSoup                       │  │
│  │ 2. Extract clickable elements (buttons, links)         │  │
│  │ 3. Extract input elements with labels                  │  │
│  │ 4. Classify elements (mock_llm.classify_element)      │  │
│  │ 5. Build CSS selectors                                │  │
│  │ 6. Infer flows (e.g., login flow)                     │  │
│  │ 7. Extract API endpoints from HAR                     │  │
│  │ 8. Save semantic_model.json & api_catalog.json        │  │
│  └──────────────────────────────────────────────────────┘  │
└────┬─────────────────────────────────────────────────────────┘
     │ 4. POST /jobs/{id}/generate
     ▼
┌─────────────────────────────────────────────────────────────┐
│  Test Generation (llm_adapter.py)                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 1. Load semantic_model.json                           │  │
│  │ 2. Call LLM adapter (MockLLMAdapter or OpenAIAdapter)│  │
│  │ 3. Generate Playwright JSON steps                     │  │
│  │ 4. Validate steps (validator.py)                      │  │
│  │ 5. Calculate confidence score                         │  │
│  │ 6. Save generated_test.json & .feature                │  │
│  └──────────────────────────────────────────────────────┘  │
└────┬─────────────────────────────────────────────────────────┘
     │ 5. POST /tests/{testId}/run
     ▼
┌─────────────────────────────────────────────────────────────┐
│  Runner Worker                                               │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 1. Load generated_test.json                           │  │
│  │ 2. Launch Playwright (Chromium)                       │  │
│  │ 3. Execute steps:                                      │  │
│  │    • goto(url)                                        │  │
│  │    • fill(selector, value)                            │  │
│  │    • click(selector)                                  │  │
│  │    • expectText(selector, value)                      │  │
│  │ 4. Capture screenshot per step                        │  │
│  │ 5. Record step results                                │  │
│  │ 6. Generate test_report_{runId}.json                  │  │
│  │ 7. Save last_run.json                                 │  │
│ 

============================================================
RUNNER
============================================================
 └──────────────────────────────────────────────────────┘  │
└────┬─────────────────────────────────────────────────────────┘
     │ 6. GET /jobs/{id}/report
     ▼
┌─────────┐
│  User   │
└─────────┘
```

---

## 3. Detailed Component Analysis

### 3.1 Backend API (`apps/backend/`)

**Purpose**: Central FastAPI application that orchestrates the entire QA automation workflow.

#### 3.1.1 Core Files

**`main.py`** - Application entry point

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from routes import jobs, tests
from db import init_db

app = FastAPI(title="Autonomous QA Automation WebApp Demo")

# CORS enabled for web UI
app.add_middleware(CORSMiddleware, allow_origins=["*"], ...)

@app.on_event("startup")
def on_startup() -> None:
    init_db()  # Auto-create tables

app.include_router(jobs.router, prefix="/jobs", tags=["jobs"])
app.include_router(tests.router, prefix="/tests", tags=["tests"])
```

**Key Features:**

- Auto-initializes database schema on startup
- CORS middleware for cross-origin requests
- Modular router structure for API endpoints

**`db.py`** - Database models and session management

```python
class Job(Base):
    __tablename__ = "jobs"
    id = Column(String, primary_key=True, default=lambda: f"job_{uuid.uuid4().hex}")
    target_url = Column(String, nullable=False)
    scope = Column(SAEnum(JobScope), nullable=False)  # read-only | sandbox
    test_profile = Column(String, nullable=False)
    owner_id = Column(String, nullable=False)
    status = Column(SAEnum(JobStatus), nullable=False)  # queued | rejected | pending | running | done
    preflight_allowed = Column(Boolean, nullable=True)
    preflight_robots = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    consent_logs = relationship("ConsentLog", back_populates="job")

class ConsentLog(Base):
    __tablename__ = "consent_logs"
    id = Column(String, primary_key=True, default=lambda: f"consent_{uuid.uuid4().hex}")
    job_id = Column(String, ForeignKey("jobs.id"), nullable=False, index=True)
    owner_id = Column(String, nullable=False)
    consent_timestamp = Column(DateTime, default=datetime.utcnow)
    note = Column(Text, nullable=True)
```

**Data Model Highlights:**

- **Job**: Tracks the entire lifecycle of a QA automation job
- **ConsentLog**: Audit trail for user consent (compliance requirement)
- Uses SQLAlchemy ORM with declarative base
- Auto-generates UUID-based IDs

**`routes/jobs.py`** - Job management endpoints

**Endpoints Implemented:**

1. **`POST /jobs`** - Create a new job

   ```python
   async def create_job(payload: JobCreateRequest, db: Session) -> JobResponse:
       # 1. Create job record
       job = Job(target_url=payload.targetUrl, scope=payload.scope, ...)
       db.add(job)
       db.flush()

       # 2. Record consent
       consent = ConsentLog(job_id=job.id, owner_id=payload.ownerId, ...)
       db.add(consent)

       # 3. Preflight robots.txt check
       robots_result = check_robots(job.target_url)
       if not robots_result.allowed:
           job.status = JobStatus.REJECTED
       else:
           job.status = JobStatus.QUEUED
           queue_adapter.enqueue_extraction(job.id)  # Trigger extraction

       db.commit()
       return JobResponse(...)
   ```

2. **`GET /jobs/{job_id}`** - Retrieve job status and metadata
3. **`GET /jobs/{job_id}/artifacts`** - List all artifacts for a job
4. **`GET /jobs/{job_id}/semantic`** - Get semantic model and API catalog (builds on-demand)
5. **`POST /jobs/{job_id}/generate`** - Generate test from semantic model
6. **`GET /jobs/{job_id}/report`** - Retrieve latest test execution report

**`routes/tests.py`** - Test execution endpoints

**`POST /tests/{test_id}/run`** - Trigger test execution

```python
async def run_test(test_id: str, payload: TestRunRequest) -> dict:
    # Enqueue test execution via Redis/RQ
    queue_adapter.enqueue_test_run(payload.jobId, test_id)
    return {"runId": "...", "status": "queued"}
```

#### 3.1.2 Supporting Services

**`preflight.py`** - Robots.txt checker

```python
def check_robots(target_url: str) -> RobotsPreflight:
    """Simple robots.txt parser that checks if crawler is allowed."""
    robots_url = urljoin(target_url, "/robots.txt")
    # Fetches and parses robots.txt
    # Returns: RobotsPreflight(allowed: bool, robots_txt: str | None)
```

**`semantic.py`** - Semantic model builder

- Parses DOM with BeautifulSoup
- Extracts UI elements (buttons, inputs, links)
- Builds CSS selectors (prefers `#id`, then `[name]`, then `.class`)
- Classifies elements using mock LLM
- Infers user flows (e.g., login flow detection)
- Extracts API endpoints from HAR

**`llm_adapter.py`** - Pluggable LLM interface

- **Protocol**: `LLMAdapter` with `generate_tests(job_id, semantic_model) -> GeneratedTest`
- **MockLLMAdapter**: Deterministic rule-based test generation
- **OpenAIAdapter**: Real OpenAI integration (enabled when `OPENAI_API_KEY` is set)
- **Factory**: `get_llm_adapter()` selects adapter based on environment

**`validator.py`** - Test step validator

- Validates action types (`goto`, `fill`, `click`, `expectText`)
- Enforces required fields per action
- Calculates confidence score
- Ensures read-only behavior (no POST/PUT/DELETE in demo)

**`storage.py`** - Storage adapter abstraction

- **LocalFSStorageAdapter**: File-based storage (demo default)
- **Interface**: `save_bytes()`, `save_json()`, `load_manifest()`, `save_manifest()`
- **S3Adapter**: Designed but not implemented (interface ready)

**`queue_adapter.py`** - Orchestration abstraction

- **OrchestrationQueue**: Redis + RQ implementation
- **Methods**: `enqueue_extraction(job_id)`, `enqueue_test_run(job_id

============================================================
CURRENT_STATE
============================================================
, test_id)`
- **Swap point**: Can be replaced with Temporal or other workflow engines

### 3.2 Extractor Worker (`apps/extractor/`)

**Purpose**: Asynchronous worker that captures page artifacts using Playwright.

**`worker.py`** - Main extraction logic

```python
def process_job(job_id: str) -> None:
    """RQ task entry point."""
    db = SessionLocal()
    try:
        job = db.query(Job).filter(Job.id == job_id).first()
        job.status = JobStatus.PENDING

        # Capture artifacts
        _capture_artifacts(job.id, job.target_url)

        job.status = JobStatus.QUEUED
        db.commit()
    finally:
        db.close()

def _capture_artifacts(job_id: str, target_url: str) -> List[ArtifactRecord]:
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        context = browser.new_context(record_har_path=str(har_path), record_har_content="embed")
        page = context.new_page()

        page.goto(target_url, wait_until="networkidle")

        # 1. DOM snapshot
        outer_html = page.evaluate("() => document.documentElement.outerHTML")
        storage_adapter.save_json(job_id, "dom.json", {"outer_html": outer_html})

        # 2. Screenshot
        page.screenshot(path=str(screenshot_file), full_page=True)

        # 3. Accessibility tree
        accessibility_tree = page.accessibility.snapshot()
        storage_adapter.save_json(job_id, "accessibility.json", accessibility_tree)

        # 4. HAR (already recorded via record_har_path)

        # Save manifest
        storage_adapter.save_manifest(job_id, records)
```

**Key Operations:**

- Launches headless Chromium browser
- Navigates to target URL and waits for network idle
- Captures DOM, screenshot, accessibility tree, and HAR
- Stores all artifacts via storage adapter
- Updates job status in database

**Dockerfile**: Uses `mcr.microsoft.com/playwright/python:v1.47.0-jammy` base image with Playwright pre-installed.

### 3.3 Runner Worker (`runner/`)

**Purpose**: Executes generated Playwright tests and produces execution reports.

**`worker.py`** - Test execution logic

```python
def run_test(job_id: str, test_id: str) -> None:
    """RQ task that executes a generated Playwright JSON test."""
    test_def = _load_test(job_id, test_id)
    steps_def = test_def.get("steps", [])

    started_at = datetime.now(timezone.utc)
    step_results = []
    status = "passed"

    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        page = browser.new_page()

        for idx, step in enumerate(steps_def, start=1):
            action = step.get("action")
            try:
                if action == "goto":
                    url = _build_url(step["url"])
                    page.goto(url, wait_until="networkidle")
                elif action == "fill":
                    page.fill(step["selector"], step["value"])
                elif action == "click":
                    page.click(step["selector"])
                elif action == "expectText":
                    locator = page.locator(step["selector"])
                    locator.wait_for(state="visible", timeout=5000)
                    text_content = locator.inner_text()
                    if step["value"] not in text_content:
                        raise AssertionError(...)

                # Capture screenshot per step
                screenshot_name = f"run_{test_id}_step_{idx}.png"
                page.screenshot(path=str(screenshot_path), full_page=True)
                step_results.append({"step": idx, "status": "passed", "screenshot": ...})
            except Exception as exc:
                status = "failed"
                step_results.append({"step": idx, "status": "failed", "error": str(exc)})
                break

    # Generate report
    report = {
        "runId": run_id,
        "testId": test_id,
        "status": status,
        "steps": step_results,
        "artifacts": artifacts,
        "startedAt": started_at.isoformat(),
        "finishedAt": finished_at.isoformat(),
    }

    storage_adapter.save_json(job_id, f"test_report_{run_id}.json", report)
    storage_adapter.save_json(job_id, "last_run.json", report)  # Latest pointer
```

**Key Features:**

- Loads test definition from `generated_test.json`
- Executes steps sequentially (stops on first failure)
- Captures screenshot after each step
- Generates structured JSON report
- Maintains `last_run.json` for easy retrieval

### 3.4 Web UI (`apps/web-ui/`)

**Purpose**: React + TypeScript frontend for job submission and result viewing.

**Technology Stack:**

- **React 18** with TypeScript
- **Vite** for build tooling
- **No UI framework** (vanilla CSS for simplicity)

**`src/App.tsx`** - Main application component

**Key Features:**

1. **Job Creation Form**: Input fields for target URL, scope, test profile, owner
2. **Job List**: Table showing all created jobs with status
3. **Job Details Panel**:
   - Status refresh button
   - Generate test button
   - Run test button
   - Refresh report button
4. **Artifact Viewer**: Lists all captured artifacts
5. **Test Report Viewer**: Displays step-by-step execution results with screenshots

**`src/api.ts`** - API client

```typescript
const API_BASE = "http://localhost:8000";

export async function createJob(payload: {
  targetUrl: string;
  scope: "read-only" | "sandbox";
  testProfile: string;
  ownerId: string;
}) {
  return request<Job>("/jobs", {
    method: "POST",
    body: JSON.stringify(payload),
  });
}
```

**API Functions:**

- `createJob()` - Submit new job
- `getJob(jobId)` - Fetch job status
- `getArtifacts(jobId)` - List artifacts
- `generateTest(jobId)` - Trigger test generation
- `runTest(jobId, testId)` - Trigger test execution
- `getReport(jobId)` - Fetch latest test report

### 3.5 Infrastructure (`infra/`)

**Purpose**: Docker Compose configuration and deployment scripts.

**`docker-compose.yml`** - Service orchestration

**Services Defined:**

1. **backend**: FastAPI application (port 8000)
2. **db**: PostgreSQL 16 (port 5432)
3. **redis**: Redis 7 (port 6379)
4. **minio**: MinIO S3-compatible storage (ports 9000, 9001) - optional
5. **extractor**: RQ worker for extraction jobs
6. **runner**: RQ worker for test execution
7. **sample-app**: Express.js demo target (port 3000)
8. **web-ui**: React development server (port 3100)

**Key Configuration:**

- Shared volume `backend_artifacts` for artifact storage
- Health checks for database (backend waits for DB to be healthy)
- Environment variables for all services
- Network isolation with Docker internal DNS

**`smoke.sh`** - End-to-end smoke test script

- Starts essential services
- Waits for health checks
- Creates a test job
- Verifies job creation

### 3.6 Sample App (`sample-app/`)

**Purp

============================================================
TESTING
============================================================
ose**: Deterministic demo target application for testing the system.

**`server.js`** - Express.js application

```javascript
app.get("/sample-app", (req, res) => {
  res.send(`
    <html>
      <h1>Sample App</h1>
      <a href="/sample-app/login">Go to Login</a>
    </html>
  `);
});

app.get("/sample-app/login", (req, res) => {
  res.send(`
    <html>
      <h1>Login</h1>
      <form id="loginForm">
        <input type="text" id="username" name="username" placeholder="Username" />
        <input type="password" id="password" name="password" placeholder="Password" />
        <button type="submit" id="login">Login</button>
      </form>
      <script>
        document.getElementById('loginForm').addEventListener('submit', (e) => {
          e.preventDefault();
          document.body.innerHTML += '<h2>Welcome</h2>';
        });
      </script>
    </html>
  `);
});
```

**Features:**

- Simple login form with username/password inputs
- JavaScript handler that appends "Welcome" heading on submit
- Deterministic behavior for consistent test results

---

## 4. Data Models & Contracts

### 4.1 Database Schema

**`jobs` Table:**
| Column | Type | Description |
|--------|------|-------------|
| `id` | String (PK) | Auto-generated `job_{uuid}` |
| `target_url` | String | URL to test |
| `scope` | Enum | `read-only` or `sandbox` |
| `test_profile` | String | Test profile identifier |
| `owner_id` | String | User/owner identifier |
| `status` | Enum | `queued`, `rejected`, `pending`, `running`, `done` |
| `preflight_allowed` | Boolean | Result of robots.txt check |
| `preflight_robots` | Text | Raw robots.txt content |
| `created_at` | DateTime | Job creation timestamp |
| `updated_at` | DateTime | Last update timestamp |

**`consent_logs` Table:**
| Column | Type | Description |
|--------|------|-------------|
| `id` | String (PK) | Auto-generated `consent_{uuid}` |
| `job_id` | String (FK) | Reference to `jobs.id` |
| `owner_id` | String | User who gave consent |
| `consent_timestamp` | DateTime | When consent was recorded |
| `note` | Text | Optional consent note |

### 4.2 API Request/Response Formats

**`POST /jobs` Request:**

```json
{
  "targetUrl": "http://sample-app:3000/sample-app/login",
  "scope": "read-only",
  "testProfile": "functional",
  "ownerId": "demo_user"
}
```

**`POST /jobs` Response:**

```json
{
  "jobId": "job_abc123...",
  "status": "queued",
  "preflight": {
    "allowed": true,
    "robots": null
  },
  "createdAt": "2026-01-16T10:00:00Z",
  "consent": [
    {
      "ownerId": "demo_user",
      "consentTimestamp": "2026-01-16T10:00:00Z",
      "note": "Demo consent recorded"
    }
  ]
}
```

**`GET /jobs/{jobId}/semantic` Response:**

```json
{
  "semanticModel": {
    "elements": [
      {
        "id": "el_1",
        "selector": "#username",
        "role": "username_input",
        "label": "Username",
        "confidence": 0.95
      },
      {
        "id": "el_2",
        "selector": "#password",
        "role": "password_input",
        "label": "Password",
        "confidence": 0.95
      },
      {
        "id": "el_3",
        "selector": "#login",
        "role": "login_button",
        "label": "Login",
        "confidence": 0.95
      }
    ],
    "flows": [
      {
        "id": "flow_login",
        "description": "Basic login flow inferred from semantic elements.",
        "steps": [
          { "action": "fill", "target": "el_1" },
          { "action": "fill", "target": "el_2" },
          { "action": "click", "target": "el_3" }
        ]
      }
    ]
  },
  "apiCatalog": {
    "endpoints": [
      {
        "method": "GET",
        "url": "http://sample-app:3000/sample-app/login",
        "status": 200,
        "sampleRequestBody": null,
        "sampleResponseBody": "<html>..."
      }
    ]
  }
}
```

**`POST /jobs/{jobId}/generate` Response:**

```json
{
  "testId": "t_1",
  "jobId": "job_abc123...",
  "steps": [
    { "action": "goto", "url": "/sample-app/login" },
    { "action": "fill", "selector": "#username", "value": "demo" },
    { "action": "fill", "selector": "#password", "value": "demo" },
    { "action": "click", "selector": "#login" },
    { "action": "expectText", "selector": "h2", "value": "Welcome" }
  ],
  "confidence": 0.95,
  "format": "playwright-json",
  "status": "ready"
}
```

**`GET /jobs/{jobId}/report` Response:**

```json
{
  "runId": "run_xyz789...",
  "testId": "t_1",
  "status": "passed",
  "steps": [
    {
      "step": 1,
      "status": "passed",
      "screenshot": "job_abc123/run_t_1_step_1.png"
    },
    {
      "step": 2,
      "status": "passed",
      "screenshot": "job_abc123/run_t_1_step_2.png"
    }
  ],
  "artifacts": [
    "job_abc123/run_t_1_step_1.png",
    "job_abc123/run_t_1_step_2.png"
  ],
  "startedAt": "2026-01-16T10:05:00Z",
  "finishedAt": "2026-01-16T10:05:13Z"
}
```

### 4.3 Artifact Storage Structure

```
/data/artifacts/
  job_abc123/
    dom.json                    # DOM snapshot
    screenshot.png              # Full-page screenshot
    trace.har                   # Network trace (HAR format)
    accessibility.json          # Accessibility tree
    manifest.json               # Artifact manifest
    semantic_model.json         # Generated semantic model
    api_catalog.json            # API endpoint catalog
    generated_test.json         # Generated Playwright test
    generated_test.feature       # Gherkin feature file
    test_report_run_xyz.json    # Test execution report
    last_run.json               # Pointer to latest report
    run_t_1_step_1.png         # Step screenshots
    run_t_1_step_2.png
    ...
```

**`manifest.json` Format:**

```json
[
  {
    "name": "dom.json",
    "type": "dom",
    "path": "job_abc123/dom.json"
  },
  {
    "name": "screenshot.png",
    "type": "screenshot",
    "path": "job_abc123/screenshot.png"
  }
]
```

---

## 5. Integration Points

### 5.1 External Services

**Playwright** (Browser Automation)

- **Used by**: Extractor worker, Runner worker
- **Purpose**: Page rendering, DOM capture, test execution
- **Version**: v1.47.0 (via Microsoft Playwright Python image)
- **Configuration**: Headless Chromium, HAR recording enabled

**PostgreSQL** (Database)

- **Used by**: Backend API, Extractor worker
- **Purpose**: Job persistence, consent logging
- **Version**: 16-alpine
- **Connection**: SQLAlchemy ORM with psycopg2

**Redis** (Message Queue)

- **Used by**: Backend API, Extractor worker, Runner worker
- **Purpose**: Job queue (`jobs`), test run queue (`runs`)
- **Version**: 7-alpine
- **Library**: RQ (Redis Queue) for Python

**OpenAI** (LLM Provider - Optional)

- **Used by**: Backend API (via `OpenAIAdapter`)
- **Purpose**: Test generation (when `OP

============================================================
GAPS
============================================================
ENAI_API_KEY` is set)
- **Model**: Configurable via `OPENAI_MODEL` (default: `gpt-5-nano`)
- **Fallback**: Uses `MockLLMAdapter` if API key not provided

**MinIO** (S3-Compatible Storage - Optional)

- **Status**: Available but not wired (using localFS for demo)
- **Purpose**: Future S3 storage adapter
- **Ports**: 9000 (API), 9001 (Console)

### 5.2 Dependency Orchestration

**Service Dependencies:**

```
backend → db (health check), redis
extractor → backend, db, redis, storage
runner → redis, storage
web-ui → backend (HTTP)
```

**Startup Order:**

1. Infrastructure services (db, redis) start first
2. Backend waits for db health check
3. Workers (extractor, runner) start after backend
4. Web UI starts after backend
5. Sample app starts independently

**Queue Flow:**

```
Backend → Redis (jobs queue) → Extractor Worker
Backend → Redis (runs queue) → Runner Worker
```

---

## 6. Current Capabilities vs Proposed System

### 6.1 Feature Implementation Matrix

| Feature                  | Status      | Implementation Details                            | Notes                                 |
| ------------------------ | ----------- | ------------------------------------------------- | ------------------------------------- |
| **Job Creation**         | ✅ Complete | `POST /jobs` with validation, consent logging     | Full implementation                   |
| **Robots.txt Preflight** | ✅ Complete | Simple parser in `preflight.py`                   | Basic implementation                  |
| **Page Extraction**      | ✅ Complete | Playwright-based DOM/HAR/screenshot/accessibility | Full artifact capture                 |
| **Semantic Modeling**    | ✅ Complete | Heuristic parser + mock LLM classification        | Rule-based, not ML                    |
| **API Discovery**        | ✅ Complete | HAR parsing for XHR endpoints                     | Basic extraction                      |
| **Test Generation**      | ✅ Complete | Mock LLM adapter (deterministic)                  | OpenAI adapter available but optional |
| **Test Validation**      | ✅ Complete | Schema validation + read-only enforcement         | Confidence scoring                    |
| **Test Execution**       | ✅ Complete | Playwright runner with step-by-step execution     | Screenshot per step                   |
| **Result Reporting**     | ✅ Complete | Structured JSON reports with artifacts            | Full implementation                   |
| **Web UI**               | ✅ Complete | React dashboard for job submission and results    | Minimal but functional                |
| **Docker Deployment**    | ✅ Complete | Full docker-compose setup                         | Production-ready structure            |
| **CI/CD**                | ✅ Complete | GitHub Actions with pytest + smoke tests          | Basic but functional                  |

### 6.2 Missing Features (Production Requirements)

| Feature                          | Status     | Priority | Implementation Notes                       |
| -------------------------------- | ---------- | -------- | ------------------------------------------ |
| **Real LLM Integration**         | ⚠️ Partial | High     | OpenAI adapter exists but needs refinement |
| **S3 Storage Adapter**           | ❌ Missing | Medium   | Interface defined, implementation needed   |
| **Temporal Orchestration**       | ❌ Missing | High     | Replace Redis/RQ with Temporal workflows   |
| **Multi-Tenancy**                | ❌ Missing | High     | User isolation, workspace management       |
| **Authentication/Authorization** | ❌ Missing | High     | OAuth, JWT, role-based access              |
| **Test Retry Logic**             | ❌ Missing | Medium   | Automatic retry on failure                 |
| **Error Scenario Generation**    | ❌ Missing | Medium   | Generate negative test cases               |
| **Multiple Tests Per Job**       | ❌ Missing | Low      | Currently one test per job                 |
| **Test Framework Support**       | ❌ Missing | Low      | Only Playwright JSON, add Cypress/Selenium |
| **Performance Testing**          | ❌ Missing | Low      | Load testing, performance metrics          |
| **Visual Regression**            | ❌ Missing | Low      | Screenshot comparison                      |
| **API Testing**                  | ⚠️ Partial | Medium   | API catalog exists but no test generation  |
| **CI Integration**               | ❌ Missing | Medium   | Webhooks, GitHub Actions integration       |

### 6.3 Completeness Assessment

**Core Flow Completeness: 100%**

- ✅ Job creation → Extraction → Semantic modeling → Test generation → Execution → Reporting

**Production Readiness: ~40%**

- ✅ Architecture and adapters are production-ready
- ⚠️ Missing: Auth, multi-tenancy, scaling, monitoring
- ⚠️ Partial: LLM integration, storage adapters

**Demo Readiness: 100%**

- ✅ All demo acceptance criteria met
- ✅ Deterministic and repeatable
- ✅ Fully containerized
- ✅ Documentation complete

---

## 7. Tests & Quality

### 7.1 Test Coverage

**Unit Tests** (`apps/backend/tests/`):

- ✅ `test_validator.py` - Validates test step validation logic
- ✅ `test_mock_llm.py` - Tests mock LLM adapter behavior
- ✅ `test_semantic_selector.py` - Tests CSS selector generation

**Integration Tests**:

- ✅ `infra/smoke.sh` - End-to-end smoke test
- ✅ Docker Compose integration (services start and communicate)

**Test Execution:**

```bash
# Unit tests (inside Docker)
docker exec qa-backend python -m pytest /app/tests -v

# Or locally (requires dependencies)
cd apps/backend
pytest tests/ -v

# Smoke test
cd infra
./smoke.sh
```

### 7.2 Quality Metrics

**Code Quality:**

- ✅ Type hints used throughout Python code
- ✅ Pydantic models for request/response validation
- ✅ SQLAlchemy ORM for type-safe database access
- ✅ React TypeScript for frontend type safety

**Linting:**

- ⚠️ No explicit linting configuration (flake8, black, eslint)
- ⚠️ No pre-commit hooks

**Test Coverage:**

- ⚠️ Limited unit test coverage (~30% estimated)
- ✅ Critical paths tested (validator, mock LLM, selector generation)
- ⚠️ Missing: Integration tests for full flows, error handling tests

### 7.3 Known Issues

1. **OpenAI API Key Hardcoded**: Currently hardcoded in docker-compose.yml (security risk)
2. **No Error Recovery**: Workers don't retry failed jobs
3. **No Timeout Handling**: Long-running extractions may hang
4. **Limited Test Scenarios**: Only happy-path tests generated

---

## 8. Build & Deployment

### 8.1 Local Development Setup

**Prerequisites:**

- Docker Desktop
- Docker Compose v2+
- Git

**Quick Start:**

```bash
# Clone repository
git clone https://github.com/wajeehahmedkhan01/AGENT-QA.git
cd AGENT-QA

# Start all services
cd infra
docker-compose up --build

# Wait for services to be healthy (~30 seconds)
# Access:
# - Web UI: http://localhost:3100
# - Backend API: http://localhost:8000
# - API Docs: http://localhost:8000/docs
# - Sample App: http://localhost:3000/sample-app
```

### 8.2 Dependencies

**Backend (`apps/backend/requirements.txt`):**

```
fastapi==0.115.0
uvicorn[standard]==0.30.6
psycopg2-binary==2.9.9
SQLAlchemy==2.0.35
alembic==1.13.2
python-dotenv==1.0.1
redis==5.0.8
rq==1.16.2
pydantic==2.9.2
pydantic-settings==2.6.0
httpx==0.27.2
beautifulsoup4==4.12.3
pytest==8.3.3
openai==1.57.0
```

**Frontend (`apps/web-ui/package.json`):**

```json
{
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react-swc": "^3.7.1",
    "typescript": "^5.5.4",
    "vite": "^5.4.21"
  }
}
```

### 8.3 Configuration

**Environment Variables** (see `docs/CONFIG.md` for full list):

**Backend:**

- `DATABASE_URL` - PostgreSQL connection string
- `REDIS_URL` - Redis connection string
- `STORAGE_BACKEND` - `localfs` or `s3` (future)
- `STORAGE_ROOT` - Artifact storage root path
- `OPENAI_API_KEY` - Optional, enables OpenAI adapter
- `OPENAI_MODEL` - OpenAI model name (default: `gpt-5-nano`)

**Web UI:**

- `VITE_BACKEND_URL` - Backend API URL (default: `http://localhost:8000`)

### 8.4 CI/CD Pipeline

**GitHub Actions** (`.github/workflows/ci.yml`):

1. Sets up Python 3.11
2. Installs backend dependencies
3. Runs pytest unit tests
4. Runs docker-compose smoke test

**Pipeline Status:**

- ✅ Automated on push/PR to `main`
- ✅ Tests Postgres and Redis services
- ✅ Validates end-to-end job creation

---

## 9. Code Style & Conventions

### 9.1 Languages & Frameworks

**Backend:**

- **Language**: Python 3.11
- **Framework**: FastAPI
- **ORM**: SQLAlchemy 2.0
- **Validation**: Pydantic v2
- **Async**: FastAPI async/await pattern

**Frontend:**

- **Language**: TypeScript 5.5
- **Framework**: React 18
- **Build Tool**: Vite 5
- **Styling**: Vanilla CSS (no framework)

**Workers:**

- **Language**: Python 3.11
- **Browser Automation**: Playwright (Python)
- **Queue**: RQ (Redis Queue)

### 9.2 Patterns & Conventions

**Adapter Pattern:**

- All external dependencies abstracted behind adapter interfaces
- Examples: `LLMAdapter`, `StorageAdapter`, `OrchestrationQueue`
- Enables easy swapping for production components

**Dependency Injection:**

- FastAPI dependency system for database sessions
- Environment-based configuration via `pydantic-settings`

**Repository Pattern:**

- SQLAlchemy models as data access layer
- Business logic separated in route handlers

**12-Factor App:**

- Configuration via environment variables
- Stateless services
- Logging to stdout (container-friendly)

### 9.3 Code Organization

```
apps/backend/
  ├── main.py              # FastAPI app entry
  ├── config.py            # Settings (pydantic-settings)
  ├── db.py                # SQLAlchemy models
  ├── routes/              # API route handlers
  │   ├── jobs.py
  │   └── tests.py
  ├── semantic.py          # Semantic model builder
  ├── llm_adapter.py       # LLM abstraction
  ├── storage.py           # Storage abstraction
  ├── queue_adapter.py     # Orchestration abstraction
  ├── validator.py         # Test validator
  ├── preflight.py         # Robots.txt checker
  └── tests/               # Unit tests
```

---

## 10. Documentation

### 10.1 Existing Documentation

**Architecture & Design:**

- ✅ `docs/ARCHITECTURE.md` - System architecture overview
- ✅ `docs/CONFIG.md` - Configuration reference
- ✅ `docs/STATUS.md` - Project status and completion tracking
- ✅ `docs/IMPLEMENTATION_ANALYSIS.md` - This document

**Operational:**

- ✅ `docs/DEMO_RUNBOOK.md` - Step-by-step demo instructions
- ✅ `docs/TESTING.md` - Testing guide with API examples
- ✅ `README.md` - Quick start and overview

**Code Documentation:**

- ⚠️ Limited inline docstrings
- ⚠️ No API documentation generation (OpenAPI available at `/docs`)

### 10.2 Missing Documentation

- ❌ API client SDK examples (Python, JavaScript)
- ❌ Deployment guide for production environments
- ❌ Monitoring and observability setup
- ❌ Troubleshooting guide
- ❌ Performance tuning guide
- ❌ Security best practices

---

## 11. Walkthrough Example

### 11.1 Complete End-to-End Flow

**Step 1: Create a Job**

```bash
curl -X POST "http://localhost:8000/jobs" \
  -H "Content-Type: application/json" \
  -d '{
    "targetUrl": "http://sample-app:3000/sample-app/login",
    "scope": "read-only",
    "testProfile": "functional",
    "ownerId": "demo_user"
  }'
```

**Response:**

```json
{
  "jobId": "job_abc123def456",
  "status": "queued",
  "preflight": {"allowed": true, "robots": null},
  "createdAt": "2026-01-16T10:00:00Z",
  "consent": [{"ownerId": "demo_user", ...}]
}
```

**Step 2: Wait for Extraction** (automatic, ~10-30 seconds)

**Step 3: Check Artifacts**

```bash
curl "http://localhost:8000/jobs/job_abc123def456/artifacts"
```

**Response:**

```json
[
  { "name": "dom.json", "type": "dom", "path": "job_abc123def456/dom.json" },
  {
    "name": "screenshot.png",
    "type": "screenshot",
    "path": "job_abc123def456/screenshot.png"
  },
  { "name": "trace.har", "type": "har", "path": "job_abc123def456/trace.har" },
  {
    "name": "accessibility.json",
    "type": "accessibility",
    "path": "job_abc123def456/accessibility.json"
  }
]
```

**Step 4: Generate Semantic Model**

```bash
curl "http://localhost:8000/jobs/job_abc123def456/semantic"
```

**Step 5: Generate Test**

```bash
curl -X POST "http://localhost:8000/jobs/job_abc123def456/generate"
```

**Response:**

```json
{
  "testId": "t_1",
  "jobId": "job_abc123def456",
  "steps": [
    { "action": "goto", "url": "/sample-app/login" },
    { "a
